---
title: Paymaster
---

:::warning
  Paymaster Feature is still currently in beta
:::

## Accessing Reown Paymaster

1. Log In to your Cloud Account [here](https://cloud.reown.com/sign-in).
2. Click on your Project.
3. Click the Paymaster Tab.

## Creating a Policy
Click add policy and then follow the steps within the policy creation screen.

### 1. Select Plan

#### Free Plan

If you select the free plan, you will have *unlimited* access to sponsoring on testnet. Currently, only Sepolia is supported.

#### Pay as you go

With the pay as you go plan, you will be asked to enter credit card information. *You will not be billed anything immediately*.

Instead you will be charged based on usage, with Paymaster Credits. This is calculated using a simple formula where it is the amount of 
gas sponsored  with a 10% commission for fees.

Billing occurs monthly, however if a threshhold of 100 USD is passed there will be an immediate charge and the billing cycle will be reset.

### 2. Add Policy Basic Info 

1. Write a descriptive name for your policy
2. Add a start date for your policy. The current day and time is selected as a default. However, you can set a time in the future to align your 
policy's start date with a campaign or similar. 
3. Optionally, add an end date and your policy will automatically lapse on the end date

### 3. Select Chains

All our supported chains will be enabled by default, but it is possible to deselect someone to only sponsor transactions on selected chains

### 4. Add Policy Logic

Policy logic can be updated in one of two ways:
1. JSON editor
2. No-code builder (Not Currently Available)

There are distinct advantages to this:
1. You can maintain an auditable history of your policies by storing the JSONs for your policy
2. You can autogenerate policies for your campaigns since it's a simple JSON schema
3. The policies can be extremely flexible as you can chain conditional checks for which smart contract to target, which method within the contract, the expected gas, etc.

After this the policy will be created and if its start date is in the past, then it will be active and ready to be used.

## Sponsoring transactions

Based on [EIP 5792](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5792.md) and [ERC 7677](https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7677.md), the 
way to utilize a paymaster is simply providing the paymaster RPC URL. 

There is an `RPC URL` selector in the Paymaster screen to get chain-specific URLs. All the URLs follow the same format with only the chain ID, so you can generate the URL on your dApp based on the active chain.

### Policy Selection

By default, all policies will be validated in succession until one returns true.

## JSON Schema: A Practical Example Walkthrough

### Basics
The schema at its core is a simple object representation of the following
> Is some key from a user operation equivelant to _(or some other comparision)_  some value?

This is defined in `params` as such:
```json
{
  "key": "some_key",
  "op": "equals",
  "value": "some_value"
}
```

### Chaining Conditionals

However, where this becomes flexible is the ability to chain different conditionals together. A more concrete example is 
checking if the User Op targets a smart contract you specify and a specific function within that contract's ABI. Since those fields
are encoded within a UserOp's `callData`, we will need to use two different methods to access this information.
1. `callDataMethodEquals`: Verify that the callData targets a specific function
2. `callDataToEquals`: Verify that the callData targets a specific contract

Essentially, we want to combine the following two conditions:

```json
{
  "key": "callData",
  "op": "callDataToEquals",
  "value": "0xa123cd918..."
}
```

```json
{
  "key": "callData",
  "op": "callDataMethodEquals",
  "value": "methodFoo"
}
```

To do this, we need to zoom out and see how the `params` are set:

```json
{
  // Rest of policy..

  "params": {
    "key": "callData",
    "op": "callDataToEquals",
    "value": "0xa123cd918..."
  },
  "ands": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodFoo"
      }
    }
  ]
}
```

The new field we introduced here is `ands`. The way the schema is designed, Each `params` object, can be 
accompanied with an `ands` OR an `ors` field which is an array of more params that will require that they 
either all pass as true, or only one of them is true, respectively.

A `params` object can not have both an `ors` and
an `ands` simultanousely. However, its "children" (the params in an `ands` or `ors`) can have different conditonals than their parent.

For example, to make it so that the above policy also passes for `methodBar` and `methodBaz`, it can be ammended as follows:

```json
{
  // Rest of policy..

  "params": {
    "key": "callData",
    "op": "callDataToEquals",
    "value": "0xa123cd918..."
  },
  "ands": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodFoo"
      }
      "ors": [
        {
          "params": {
            "key": "callData",
            "op": "callDataMethodEquals",
            "value": "methodBar"
          }
        },
        {
          "params": {
            "key": "callData",
            "op": "callDataMethodEquals",
            "value": "methodBaz"
          }
        },
      ]
    }
  ]
}
```

This essentially is a schema translation of
> The UserOp should target smart contract 0xa123.. and either use the methods `methodFoo` or `methodBar` or `methodBaz`.

Note that at the top it used `ands` and then used `ors` for the children. This is fully legal within the schema.

However, the <span style={{color: 'red'}}>following is incorrect </span>:

```json
{
  // Rest of policy..

  "params": {
    "key": "callData",
    "op": "callDataToEquals",
    "value": "0xa123cd918..."
  },
  "ands": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodFoo"
      }
    }
  ],
  "ors": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBar"
      }
    },
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBaz"
      }
    },
  ]
}
```

***In this case, the `ors` will be completely ignored. If both `ors` and `ands` are present, then the `ands` will take presedence.***

### ABI Parsing

For the policy to actually know how to read the `callData` it needs to know the smart contract's ABI. 

For this we introduce 2 new fields. `policyStaticProps` and `metadata`. Both are essentially free range key-value 
dictionaries used to store information within the policy to be accessed later. The key thing to note is that
values within `policyStaticProps` can be accessed from within `metadata`. This becomes invaluable with policies
that have multiple conditonals like the one above.

```json
  "policyStaticProps": {
    "contract1": {
      "abi": [...Contract ABI goes here]
    }
  }
  "params": {
    "key": "callData",
    "op": "callDataMethodEquals",
    "value": "methodBaz"
  },
  {
    "metadata": {
      "contractAbi": "<contract1.abi>"
    }
  }
```

Essentially here, `contractAbi` is a variable that `callDataMethodEquals` requires. To supplement its value, we use `<contract1.abi>`.
What `<contract1.abi>` means is essentially `policyStaticProps.contract1.abi`. The `<>` indicate that this value is coming from `policyStaticProps`.

Note that the values within `policyStaticProps` can be named anything. The only constraint is that `contractAbi` is named the same within the metadata 
as that is what `callDataMethodEquals` will look for.

Extrapolating this to our running example above, the complete policy becomes:
```json
{
  "policyType": "useroperation_payload_control", /* currently the only one supported */
  "policyStaticProps": {
    "contract1": {
      "abi": [...Contract ABI goes here]
    }
  }

  "params": {
    "key": "callData",
    "op": "callDataToEquals",
    "value": "0xa123cd918..."
  },
  "ands": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodFoo"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    }
  ],
  "ors": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBar"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    },
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBaz"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    },
  ]
}
```

### Housekeeping
The final bit to making a valid policy is adding `metadata` to the root of your policy, to keep basic metadata like what chains to support, the startTime and endTime.
```json
{
  "metadata": {
    "chainIds": [
      1,        // Etheruem
      137,      // Polygon
      11155111  // Sepolia (Testnet)
    ],
    "startTime": "2024-10-23T15:50:00.000Z",
    "endTime": null
  }
}
```

Adding this to the above gives us a complete and working policy.

### Complete Example Policy
The following is the culmination of all the above steps to create a complete policy.

In English, what this policy is saying is 
> The policy starts on the 23<sup>rd</sup> of October 2024, does not expire and will support Ethereum, Polygon and Testnet. 
> For a UserOp to pass this policy, it needs to be targeting smart contract `0xa123cd918...` **and** it has to be using
> One of the following methods from the contract: `methodFoo` **or** `methodBar` **or** `methodBaz`.

```json
{
  "policyType": "useroperation_payload_control", /* currently the only one supported */
  "policyStaticProps": {
    "contract1": {
      "abi": [...Contract ABI goes here]
    }
  },
  {
    "metadata": {
      "chainIds": [
        1,        // Etheruem
        137,      // Polygon
        11155111  // Sepolia (Testnet)
      ],
      "startTime": "2024-10-23T15:50:00.000Z",
      "endTime": null
    }
  },
  "params": {
    "key": "callData",
    "op": "callDataToEquals",
    "value": "0xa123cd918..."
  },
  "ands": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodFoo"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    }
  ],
  "ors": [
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBar"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    },
    {
      "params": {
        "key": "callData",
        "op": "callDataMethodEquals",
        "value": "methodBaz"
      },
      "metadata": {
        "contractAbi": "<contract1.abi>"
      }
    },
  ]
}
```

## JSON Schema: Definitions

### `policyType`
The type of policy, currently only `useroperation_payload_control` is available.

### `policyStaticProps`
Key value pair used as data storage for the policy

### `params`
Where the core logic of a policy lives

#### `key`
The key within the UserOp to target, currently only EntryPoint v.07 is supported, so the available fields are:
1. `sender`
2. `nonce`
3. `callData`
4. `callGasLimit`
5. `verificationGasLimit`
6. `maxFeePerGas`
7. `maxPriorityFeePerGas`

#### `op`
The operation to apply within the params. Currently available:
1. `equals`: Exact 1:1 match with `value`
2. `lessThanOrEquals`: Is the numeric value less than or equals `value`
3. `callDataMethodEquals`: Within `callData`, is the `method` equal to a `value`
    * requires `contractAbi` defined in `metadata`
4. `callDataToEquals`: Within `callData`, is the `to` equal to a `value`

#### `value`
The value to be compared to. Can be a string, number or boolean.

### `metadata`
Key value pair used as data storage for a single `params`

Special fields within `metadata`. At the root of a policy, there needs to be a `metadata` object defined. 
It has to contain the following:

#### `startTime`
ISO datetime stamp of when to start policy

#### `endTime`
ISO datetime stamp of when to end policy

#### `chains`
Array of chain IDs to support. `number[]`






