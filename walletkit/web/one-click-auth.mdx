---
title: One-click Auth
description: Implement streamlined authentication for your wallet
---

# One-click Authentication

## What is One-click Auth?

One-click Auth is a streamlined authentication protocol that allows users to:
- Sign in to dApps quickly with their Ethereum wallet
- Authorize specific permissions in a single step
- Enjoy a smoother user experience with fewer confirmation prompts

This protocol combines [Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361) (SIWE) messages with [ReCaps](https://eips.ethereum.org/EIPS/eip-5573) (ReCap Capabilities) to create a secure, consent-based authentication flow.

<Frame>
![One-click Authentication Flow](/images/w3w/authenticatedSessions-light.png)
</Frame>

## Key Benefits

1. **Combined Authentication and Authorization**: Users can authenticate and grant specific permissions in one step
2. **Explicit Consent**: All authorized actions are clearly defined in human-readable format
3. **Enhanced Security**: Granular permissions prevent unauthorized access
4. **Improved UX**: Fewer confirmation steps for users

## Implementation Guide

### Step 1: Listen for Authentication Requests

First, set up an event listener for incoming authentication requests:

```typescript
walletKit.on("session_authenticate", async (payload) => {
  // We'll implement the authentication flow in the next steps
  console.log("Received authentication request:", payload);
});
```

### Step 2: Create the Authentication Payload

When an authentication request is received, populate it with your wallet's supported chains and methods:

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// Define chains and methods your wallet supports
const supportedChains = [
  "eip155:1",   // Ethereum Mainnet
  "eip155:137"  // Polygon
];

const supportedMethods = [
  "personal_sign",
  "eth_sendTransaction", 
  "eth_signTypedData"
];

// Populate the authentication payload
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
```

### Step 3: Format the Authentication Message

Create a SIWE message that the user will sign:

```typescript
// Format user's address according to CAIP-10 standard
// Format: namespace:chainId:address
const userAddress = "0x0Df6d2a56F90e8592B4FfEd587dB3D5F5ED9d6ef";
const iss = `eip155:1:${userAddress}`;

// Generate the authentication message
const message = walletKit.formatAuthMessage({
  request: authPayload,
  iss
});

// Display this message to the user for review before signing
showMessageToUser(message);
```

### Step 4: Approve Authentication (Two Approaches)

#### Approach 1: Single Authentication Object

For simple cases, you can create a single authentication object:

```typescript
// After user approves the message
const signature = await wallet.signMessage(message);

// Build the authentication object
const auth = buildAuthObject(
  authPayload,
  {
    t: "eip191",  // Signature type (EIP-191)
    s: signature, // The signature
  },
  iss
);

// Approve the authentication request
await walletKit.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth],
});
```

#### Approach 2: Multiple Authentication Objects (Recommended for Multi-chain)

For better security with multiple chains, sign a separate message for each chain:

```typescript
const auths = [];

// Create authentication objects for each chain
for (const chain of authPayload.chains) {
  // Create message specific to this chain
  const chainMessage = walletKit.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${wallet.address}`,
  });
  
  // Sign the message
  const signature = await wallet.signMessage(chainMessage);
  
  // Build authentication object for this chain
  const auth = buildAuthObject(
    authPayload,
    {
      t: "eip191",
      s: signature,
    },
    `${chain}:${wallet.address}`
  );
  
  auths.push(auth);
}

// Approve with multiple authentication objects
await walletKit.approveSessionAuthenticate({
  id: payload.id,
  auths,
});
```

> **Note**: While you can authenticate multiple chains with a single signature, creating separate signatures for each chain provides better security.

### Step 5: Rejecting Authentication Requests

If the user decides not to approve the authentication request:

```typescript
import { getSdkError } from "@walletconnect/utils";

await walletKit.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError("USER_REJECTED"),
});
```

## Important Considerations

1. **Session Creation**: Not all authentication approvals result in a new session. Some dApps may want to authenticate users without creating a persistent session.

2. **Message Display**: Always show the authentication message to users before signing so they can review the permissions they're granting.

3. **Signature Types**: The examples use EIP-191 signatures, which are standard for Ethereum wallets.

## Testing Your Implementation

You can test your One-click Auth implementation using the AppKit Lab:

<Card
  title="Test One-click Auth Integration"
  href="https://appkit-lab.reown.com/library/ethers-siwe/"
  icon="flask"
  color="#4D72DA"
/>

## Common Issues and Solutions

- **Invalid Signature**: Ensure you're using the correct private key and message format
- **Chain Mismatch**: Verify that the chains in your authentication payload match what the dApp is requesting
- **Missing Methods**: Confirm that your supported methods include what the dApp needs
